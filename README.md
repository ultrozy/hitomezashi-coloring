# Раскраска узоров Хитомезаши

&emsp;Узор Хитомезаши образуются из чередующихся вертикальных и горизонтальных чёрточек, образующая их последовательность первых чёрточек определяет весь узор.
Получаемый узор образует области, которые можно окрасить в два цвета. Данный модуль содержит функции для окраски узора в два и более цветов.</br></br>


Достигались следующие цели:
1) Две соседние области должны иметь близкие цвета, но не совсем одинаковые
2) Раскраска должна быть красочной, то есть цвета областей должны иметь высокую насыщенность (Saturation в HSV и HSL)
3) Должна иметься возможность выбрать какие цвета будут преобладать в раскраске (список preferred_colors)

</br></br>&emsp;Функция buildField отвечает за постройку бесцветного узора. Так как узор всегда раскрашиваем в два цвета, каждая клетка обозначается с помощью меток 0 и 1, обозначая каждую область как связное множество достижимых клеток с одинаковой меткой.
</br>&emsp;Аргументами функции являются размеры узора и являются ли образующие последовательности последовательностями Морса-Туэ. Если thue_morse ложно, последовательности случайны.

</br></br>&emsp;Функция colorMap отвечает за выделение отдельных областей в поле. Две клетки принадлежат одной области тогда и только тогда, когда имеют одинаковый номер. Номера областей варьируют от 0 до количества областей N. Каждой области позднее будет сопоставлен свой цвет.
</br>&emsp;Функция принимает на вход бесцветное поле, выдаёт размеченное поле областей и количество клеток в каждой области.
</br>&emsp;Алгоритм присваивает каждой клетке номер -1 (не находится ни в какой области), и пробегает по каждой клетке. Если у клетки номер -1, запускается поиск в глубину по всем соседям, имеющим ту же метку и номер -1, присваивая каждой клетке следующий номер и подсчитывая их количество.

</br></br>&emsp;Функция graphRegions строит граф областей и определяет для каждой области - к какому цвету из preferred_colors цвет области будет стремиться.
</br>&emsp;Функция принимает на вход карту областей, количество клеток в каждой области и количество предпочитаемых цветов (сами цвета не нужны)
</br>&emsp;Граф будет храниться в виде списка смежности, так как в этом случае будет задействовано O(n) памяти (граф будет гарантированно являться деревом, это можно легко доказать)
</br>&emsp;Инициализируется граф adj списком словарей (ключами являются соседними вершинами, значения словаря будут разъяснены позднее). При этом функция вернёт граф graph в виде списка списков. Граф adj в виде списка словарей будет изменяться в ходе определения предпочитаемых цветов каждой области.
</br>&emsp;Далее алгоритм пробегается по всем парам соседних вершин x и y, добавляя в оба словаря adj[x][y] = 0 и adj[y][x] = 0.
</br>&emsp;Далее определяется graph переводя каждый словарь в список. graph впоследствии будет возвращён.
</br>&emsp;Следующий шаг алгоритма заключается в разделении графа на num_preferred_colors связных подграфов (связных, так как соседние области должны иметь примерно одинаковый цвет). Также мы хотим, чтобы множества областей, притягивающихся к определённому предпочитаемому цвету, содержали примерно равное количество клеток (количество каждого предпочитаемого цвета в финальной картинке должно быть примерно одинаково).
</br>&emsp;Для этого adj и создавался в виде списка словарей. Так как граф является деревом, подграфы можно отщеплять последовательно по одному ребру. И для того, чтобы отщеплять каждый раз подграфы с определённым совокупным количеством клеток, определим для каждого ориентированного ребра (x -> y) количество клеток подграфа, который получается отделением по ребру (x-y), причём y лежит в подграфе. Хранить это количество будем в качестве значения словаря adj[x] по ключу y, то есть adj[x][y].
</br>&emsp;Алгоритм определяет adj[x][y] рекурсивным вызовом функции defineAllEdgeValues по 0-й вершине графа с неопределённым parent. Функция от vertex, вычисляет все adj[vertex][adjvert], где adjvert - смежные с vertex вершины. Функция от vertex вызывает себя по всем смежным вершинам child, кроме parent (иначе получится бесконечный цикл). Далее вычисляет adj[vertex][child] на основе уже вычисленных adj[child][vertex], а в конце - adj[vertex][parent] на основе суммы всех adj[vertex][child] (их связывают определённые легко выводимые соотношения)
</br>&emsp;После определения всех значений рёбер алгоритм num_preferred_colors-1 раз пробегает по всем рёбрам, выбирает лучшее для отщепления подграфа, с помощью рекурсивного вызова удаляет отщеплённый подграф, сохраняя в color_regions его вершины и совокупное число клеток, затем рекурсивным вызовом обновляет изменённые adj[x][y] у оставшихся вершин, так как удаление подграфа уменьшает подграфы по оставшимся рёбрам.
</br>&emsp;Сортируя color_regions по количеству клеток во множествах областей, функция возвращается color_regions (первые цвета в списке предпочитаемых более предпочитаемые)

</br></br>&emsp;Функция defineColorsCube отвечает за определения цвета каждой области. достигается это с помощью физической системы в цветовом пространстве RGB, в которой изначально каждой области даются случайные цвета, а затем ищется стабильное состояние, в котором считается, что цвета уже определены.
</br>&emsp;В физической системе работают следующие силы:
1) Сила притяжения к аттрактору - RGB представление соответствующего области предпочитаемого цвета
2) Сила отталкивания от нулевой насыщенности (отрезок от белого к чёрному цвету)
3) Сила отталкивания по ребру - если евклидово расстояние между цветами СОСЕДНИХ областей мало, на них действует сила отталкивания. Причём более массивная область (с бОльшим количеством клеток) испытывает мЕньшее отталкивание во столько раз, во сколько больше количество клеток.
4) Сила притяжения по ребру - если евклидово расстояние между цветами СОСЕДНИХ областей слишком большое, на них действует сила притяжения. Аналогично, массивная область испытывает мЕньшее притяжение.
5) После вычисления вышеизложенных сил, изменения скоростей и движения точек, происходит жёсткий ввод вышедших из RGB куба точек обратно, ставя их на границу и обнуляя соответствующую составляющую скорости
</br>&emsp;Условие на меньшую силу для больших областей сделано для того, чтобы маленькие области не уводили и не выталкивали большие области от аттракторов, именно большие области должны иметь наиболее предпочитаемый цвет.
</br>&emsp;Аналогично уменьшению силы на большие области НЕ сделано увеличение силы на маленькие области для того, чтобы большие области не сильно отталкивали маленькие и не вытесняли к краю RGB куба.
</br>&emsp;Физическая система каждую итерацию вычисляет изменение скоростей и положений на основе вычисленных сил и текущего dt - отрезка времени. Отрезок времени dt определяется динамически на основе максимального движения (изменения положения) среди нескольких последних итераций TIMES_ITERATIONS среди всех точек. Если максимальное движение достаточно большое, dt уменьшается в 2 раза (чтобы точки не врезались каждый раз втупую в стены). Если движение стало достаточно малым, считается, что алгоритм приближается к стабильному состоянию и dt увеличивается в 2 раза. При достижении определённого большого dt и малого максимального движения алгоритм заканчивает исполнение.
</br>&emsp;TIMES_ITERATIONS рекомендуется брать не меньше 3, так как даже если точки летают из-за большого dt и больших сил, они могут останавливаться на итерацию вследствие обнуления скоростей на границе.

</br></br>&emsp;Функция drawByPyplot рисует финальное изображение.

</br></br>&emsp;Функция HitomezashiColoring объединяет все функции.
